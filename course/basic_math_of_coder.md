## [程序员的数学基础课](https://time.geekbang.org/column/intro/143) 黄申

#course #math

### why

- 机器学习表面上是“写程序”，但实际上剥去外表，本质上就是在研究数学
- 数学学得好不好，将会直接决定一个程序员有没有发展潜力。
  - 往大了说，数学它其实是一种思维模式，考验的是一个人归纳、总结和抽象的能力.
  - 往小了说，不管是数据结构与算法还是程序设计，其实底层很多原理或者思路都是源自于数学
- 编程语言是血肉，数学的思想和知识是灵魂
- 余数
  - 分页 根据记录总条数和每页展示条数，计算整体页数
  - 再难一点，奇偶校验、循环冗余检验、散列函数、密码学等等都有余数相关的知识。
  - 遇到这些问题的时候，能说不懂余数吗？只是很多时候没有想到可以用余数思想来解决相关问题罢了。那为什么没有想到呢？本质原因还是没有数学思维，还是数学的基础不够好。
- 定义好了专栏边界:只做程序员需要学的数学知识
- 数学理论和编程实践的结合其实是“决裂”的，所以学习数学的时候，不能太功利，觉得今天学完明天就能用得着的学习思路可以用在其他课程上，但放在数学里绝对不合适。
  - 数学知识总是比较抽象，特别是概率统计和线性代数中的概率、数据分布、矩阵、向量等概念。它们真的很不好理解，需要花时间琢磨，但是对于高级一点的程序设计而言，特别是和数据相关的算法，这些概念就非常重要了，这可都是先人总结出来的经验。
  - 如果能够将这些基本概念和核心理论都搞懂、搞透，那么面对系统框架设计、性能优化、准确率提升这些难题的时候，就能从更高的角度出发去解决问题，而不只是站在一个“熟练工”的视角，去增删改查。
- 希望数学能够成为一种基础能力，希望这个专栏能帮用数学思维来分析问题和解决问题。数学思想是启发思维的中枢，如果对数学有更好的理解，遇到问题的时候就能追本溯源，快、准、稳地找到解决方案。
- 对于程序开发这个职业来说，数学和英语是非常重要

### How

- 刘超 “学数学就像学一门新技术”
  - 不建议 将大学的数学书拿出来啃一遍，一来耗费大量时间，二来和实际应用结合不起来，往往该看的忽略了，不该看的费了半天劲用不上，过一阵又忘了
  - 学数学和学一门新技术一样：先用起来，了解实现原理，然后了解为什么这样实现
- 徐文浩  “先广度，再深度”
  - 投入时间学习数学原因，一来，在工作中用得上；二来，学点数学很多时候是个有趣的事。
    - 重新认识和理解“程序”和“问题的解决方案”这两件事情。
      - 大部分应用领域的核心解决方案，都是把应用领域的问题，形式化为一个个数学问题。
      - 在找到数学问题的“解法”之后，用写程序的方式翻译成实际应用的“算法”。
      - 能够应用“数学”的方式来解决问题，是从一个只能套用现成方案的“码农”向能够将新问题形式化、并找出创新解决方案的“研发工程师”迈出的第一步。
    - 很多问题当知道如何用数学来解决的时候，常常会有醍醐灌顶的感觉。譬如当第一次搞明白，广告中的竞价问题，居然能够变成一个博弈论中“寻找上策均衡”的问题，并且能够通过简简单单的公式表示出来的时候
    - 一旦熟悉机器学习中用到的数学知识，很多想要解决的系统问题，都能通过定义更好的数学优化目标，变成一个能够找到最优解的程序算法，最后通过写个程序，翻译成数学问题来解决
  - 如何学 从工作相关的领域开始，先广度，再深度
    - 从工作相关的领域开始，是让自己一是能有实际用得上学到的知识的机会，二是日常工作中容易耳濡目染，相当于常常在复习。
    - 先有广度，是让自己在心中有一个问题到解决方法的“地图”，遇到具体的问题能够对得上，容易获得正反馈
    - 再有深度，具体去对一个特定的主题学习应用。
  - 当开始深入学一个特定问题的时候，最好的方式是，追一门在线课程，譬如 Coursera、TEDx，或者在极客时间上找一门课程来学习。
    - 在线课程有明确的节奏，通常还会提供作业和测验。
    - 通过作业和测验，让自己对自己的学习有一个联系和反馈的过程。即使实践中没有足够的应用，过一段时间有些知识没有那么熟悉了，但是也容易建立自己很快可以“捡”回来的信心，降低“复习”的启动成本。
    - 跟随在线课程的节奏，可以有效避免“三天打渔两天晒网”的恶习，让学习有始有终。
  - 针对学习的内容写一点程序 把正在学习的问题的解法，写一个算法实现出来。这是一个非常有效的练习方式。譬如学习线性代数，理解仿射，反复读书的效率对我来说，就不如找来 Coding The Matrix，通过写程序，让学习、理解变得更深入。
- 王天一 “数学是工具而非问题，是手段而非目的”
  - 在数学的学习中，首要的问题是明确需求。作为非数学专业出身的“外行”，使用数学的目的不是顶天，而是立地；不是上下求索艰深的理论问题，而是将生活中的具体问题抽象化，进而加以解决。
  - 学习数学的基础在于经验而非哲学，比较实际的思路是秉持功利主义的原则，用多少学多少。掌握基本的线性代数与矩阵论、概率论与数理统计知识足以应付日常的使用，盲目地好高骛远通常有害无益。理论化和公理化这些比较深邃的尝试固然让人着迷，但它们可能并没有肉眼可见的实用性，对于绝大部分计算机从业者恐怕过于阳春白雪。
  - 在学习时还要理解数学的本质。数学是工具而非问题，是手段而非目的。探索世界奥秘的学科是“格物穷理”的物理学，相形之下，数学更像是个任人打扮的小姑娘，它存在的意义就是通过合理的设计简化物理学的研究。正因如此，在数学中存在着各种各样在现实中不可能出现的理想化模型（比如无穷小和极限的诞生），也存在着对同一个物理过程不同的建模方式（比如矩阵力学和波动力学）。充分理解数学的人造特质，可以在学习中少走很多无谓的弯路。
  - 理解数学的工具属性就会自然而然地引出了数学学习中的另一个关键点，那就是工具设计的出发点，也就是所谓的数学思想与数学逻辑。任何一个工具都不是平白无故地设计出来的，它必然要解决某个特定的问题，比如线性代数与矩阵论是对具体对象的抽象表示与运算，比如概率论和数理统计是对不确定性及其定型定量表示的建模。因此，在掌握每一种数学工具的微观技巧之前，理解它们的宏观目标是更加重要的。只有掌握了工具诞生的背景与目的，才有可能有效地使用它们。
  - 数学绝不仅仅是算术，把主要精力放在计算上未免因小失大。在经典科幻《银河系漫游指南》中，超级计算机告诉人们，世界的终极答案是“42”——这更像是对数字主义者善意嘲讽的一个梗。但对算术的过度强调并不鲜见，在相当数量的现行数学教材中，讲解线性代数时开篇便给出行列式的计算方法，这种编排着实让人费解。
  - 学习时值得突出强调的一点是举一反三的能力。同一种工具及其背后的思想可以出现在不同的场景下，解决不同的问题，但是一旦深入到本质层面，就会发现它们实际上是相通的。如何透过现象看本质，将不同场景融会贯通，才是值得锻炼的高级能力。
  - 同一个工具存在不同应用的例子不胜枚举：
    - 特征向量计算的是系统的不动点，在数据降维中有举足轻重的作用，但如果熟悉电子通信的话你就会知道，对线性时不变系统的分析（也就是各种变换）都是基于特征向量展开的
    - 在给定隐马尔可夫模型的观测序列时，可以利用维特比算法求解后验概率最大的状态序列，将这一方法应用在信道编码中，就是最经典的卷积码译码算法
    - 在分类问题中，以类间方差最大化为标准可以推导出线性判别分析和决策树等模型，应用在图像处理中，类间方差最大化原理给出的就是图像分割中的 Otsu 方法。
    - 把握数学的工具属性，学习具体方法时先溯因再求果，勤于思考解决相同问题的不同方法，与解决不同问题的相同方法之间的联系与区别
- 结构内容
  - 据结结构
    - 数组和链表就体现了迭代和递归的思想
  - 编程语句
    - 判断语句就是使用了逻辑（布尔）代数
    - 架构在这些数据结构和编程语句之上的算法，除了迭代和递归，也体现了排列、组合和动态规划等思想。
  - 基础算法
  - 机器学习算法
    - 需要理解概率统计和线性代数的核心思想，包括什么是概率、贝叶斯定理、数据的统计分布、向量、矩阵、线性方程等等。
- [code](https://github.com/shuang790228/GeekTime-MathLecture-JavaCode)

![[math_knowlegde_struct.png]]

## 基础思想

### 二进制

- 罗马数字
  - Ⅰ、Ⅱ、Ⅲ 代替手指数量，一只手 “Ⅴ”形，两只手 “ⅤⅤ”
- 阿拉伯数字
  - 由从 0 到 9 这样 10 个计数符号组成，并采取进位制法，高位在左，低位在右，从左往右书写
  - 由于阿拉伯数字本身笔画简单，演算便利，因此逐渐在各国流行起来，成为世界通用数字
- 十进制 decimal
  - 10 称为十进制计数法的基数
- 二进制 binary
  - 数位是 2^n 形式
- 计算机使用二进制和现代计算机系统的硬件实现有关。组成计算机系统的逻辑电路通常只有两个状态，即开关的接通与断开
  - 断开状态用“0”来表示，接通的状态用“1”来表示。
  - 由于每位数据只有断开与接通两种状态，所以即便系统受到一定程度的干扰时，它仍然能够可靠地分辨出数字是“0”还是“1”。
  - 在具体系统实现中，二进制数据表达具有抗干扰能力强、可靠性高的优点。
  - 适合逻辑运算
  - 逻辑运算中的加法（“或”运算）、乘法（“与”运算）以及否定（“非”运算）都可以通过“0”和“1”的加法、乘法和减法来实现。
- 负整数转换为二进制 将负整数对应正整数先转换成二进制，然后对其“取补”，再对取补后的结果加1

#### signed

- 符号位 有符号二进制数中的最高位，需要它来表示负数
  - 在实际的硬件系统中，计算机 CPU 的运算器只实现了加法器，而没有实现减法器。通过加上一个负数来达到这个目的
  - 有符号数（signed）最高位是符号位, 0 时，表示为正数；1 时，表示为负数
  - 无符号数（unsigned）最高位就不是符号位，而是二进制数字的一部分
  - Java 所有和数字相关的数据类型都是有符号位的
- 溢出 二进制数位数超过系统所指定位数。目前主流系统都支持至少 32 位整型数字
  - n 位数字 -2^(n-1) ~2^(n-1)-1
  - 符号位是 1，后面 n-1 位全是 0 表示 -2^(n-1)
  - 上溢出（overflow） 超出上限
  - 下溢出（underflow）超出下限
- 溢出后，从下限开始 最大数值加 1，变成最小数值，周而复始
  - 相当于取模
  - 取模的除数 数据类型上限减去下限的值，再加 1 `(2^(n-1)-1)-(-2^(n-1))+1=2x2^(n-1)-1+1=2^n-1+1` 为什么不直接写成 2^n 呢？因为 2^n 已经是 n+1 位了，超出 n 位所能表示的范围

![[num_flow.png|溢出]]

#### encode

- 原码 二进制的原始表示。对于有符号二进制来，原码最高位是符号位，其余位表示该数字绝对值的二进制
  - 零二异性 10000 00000 都表示 0
- 减法计算不能通过负数原码实现 `3+(-2)`
- i-j，其中 j 为正数。如果 i-j 加上取模的除数，会形成溢出，并正好能够获得 i-j 运算结果
- `i-j=(i-j)+(2^n-1+1)=i+(2^n-1-j)+1=i 原码 +(-j 反码)+1=i 原码 +(-j 补码)=i 补码 +(-j 补码)`
  - 2^n-1 不考虑符号位情况 n-1 位的 1
  - 2^n-1-j  对正数 j 二进制原码，除符号位之外按位取反（0 变 1，1 变 0）
  - 负数 -j 和正数 j 原码，除符号位之外都相同,2^n-1-j 也相当于对负数 -j 的二进制原码，除符号位之外按位取反
  - 2^n-1-j 编码称为负数 -j 反码， 反码是负数的一种表示，正数保持不变
- 把 -j 反码加上 1 定义 -j  补码
- 正数原码、反码和补码三者都一样
- 计算机通过补码正确地运算二进制减法

![[bin_substract.png|]]

#### bit operator 位操作|位运算

- 直接对内存中二进制位进行操作
- 向左移位
  - 溢出 需要将溢出的位数去除
  - 数学意义就是将数字翻倍
- 向右移位 去除末尾位
  - 数学意义 数字除以 2 并求整数商的操作
  - 逻辑右移 右移 1 位，左边补 0 即可
    - 在 Java 和 Python 语言中使用 >>> 表示
  - 算术右移 保持符号位不变，除符号位之外的右移一位并补符号位 1。补的 1 仍然在符号位之后。
  - 在 C 或 C++ 语言中，逻辑右移和算数右移共享同一个运算符 >>，编译器是如何决定使用逻辑右移还是算数右移呢？
    - 取决于运算数类型 unsigned 采用逻辑右移; signed 采用算数右移
    - unsigned 类型算数右移，或者 signed 类型逻辑右移，首先需要进行类型转换
- 或
- 与
  - 验证奇偶数
    - 偶数二进制最后一位总是 0，而奇数的二进制最后一位总是 1
    - 和数字 1 二进制进行按位“与”操作，取得数字二进制最后一位，再进行判断
- 异或
  - 排异性 参与操作的位相同，结果为 0（假），否则为 1（真）
  - 所有数值和自身进行按位“异或”操作之后都为 0。而且要通过“异或”操作得到 0，也必须通过两个相同的数值进行按位“异或”。
  - 两个数值按位“异或”结果为 0 <=> 两个数值相等 可以作为判断两个变量是否相等的条件。
  - 交换两个数字
- 集合操作
  - 集合转换成 BitSet
  - 集合{1, 3, 8}和{4, 8},转为两个 8 位二进制数，从右往左以 1 到 8 依次来编号,如果某个数字在集合中，相应的位置 1，否则置 0
  - 10000101  10001000
  - 与 代表两个集合的交
  - 或 代表两个集合的并
  - elasticsearch 的filter查询，用 bitset 就是位运算

```java
x = (x ^ y);
y = x ^ y;
x = x ^ y;
```

### 余数：原来取余操作本身就是个哈希函数

- 余数总是在一个固定的范围内。
- 取余可以通过某一种关系，让没有边界的整数处于一个确定的边界内 无线=>有限
- 同余定理 两个整数 a 和 b，如果它们除以正整数 m 得到余数相等，可以说 a 和 b 对于模 m 同余
  - 奇数和偶数是同余定理的一个应用
- **用来分类** 把无穷多个输入分成有限多个类
- 哈希（Hash）|散列 将任意长度输入，通过哈希算法，压缩为某一固定长度的输出
  - 哈希函数 f(x) = (x + MAX) mod size
  - 较大随机数 MAX 被分配到同一个空间中的记录就更加“随机”，更适合需要将数据重新洗牌的应用场景，比如加密算法、MapReduce 中的数据分发、记录的高速查询和定位等等。
- 加密算法
- 循环冗余校验
- 真正学懂数学的人却没几个。希望可以从余数这个小概念开始，认识到数学思想其实非常实用，用好这些知识，对编程，甚至生活都有意想不到的作用。

### 迭代 Iterative

- 不断地用旧变量值，递推计算新变量值
- 通过循环语言来实现
- 求数值的精确或者近似解
  - 二分法（Bisection method）
    - 计算某个给定正整数 n（n>1）的平方根
    - 平方根一定小于 n 本身，并且大于 1
    - 二分查找 假设值在目标值左右不断波动，最后到达误差范围内
    - deltaThreshold 误差阈值 控制解的精度
    - 用 maxTry 控制循环的次数。之所以没用 while(true) 循环，是为避免死循环
  - 牛顿迭代法（Newton’s method）
    - 牛顿在 17 世纪提出的一种方法，用于求方程的近似解。
    - 以微分为基础，每次迭代的时候，会去找到比上一个值更接近方程的根，最终找到近似解。
- 在一定范围内查找目标值。典型方法包括二分查找
  - 在自然语言处理中，常要处理同义词或者近义词扩展。手头上会有一个同义词 / 近义词的词典。对于一个待查找单词，需要在字典中找出这个单词，以及它所对应的同义词和近义词，然后进行扩展。
  - 比如说，字典里有一个关于“西红柿”的词条，其同义词包括了“番茄”和“tomato”。
    - 处理文章时，看到“西红柿”这个词，就去字典里查一把，拿出“番茄”“tomato”等等，并添加到文章中作为同义词 / 近义词扩展
    - 用户在搜索“西红柿” 的时候，就能确保出现“番茄”或者“tomato”文章会被返回给用户
  - 用二分查找法进行字典查询
    - 将整个字典先进行排序（假设从小到大）。二分法中很关键的前提条件是，所查找的区间是有序的。这样才能在每次折半的时候，确定被查找的对象属于左半边还是右半边。
    - 使用二分法逐步定位到被查找的单词。每次迭代的时候，都找到被搜索区间的中间点，看看这个点上的单词，是否和待查单词一致。如果一致就返回；如果不一致，要看被查单词比中间点上的单词是小还是大。如果小，那说明被查的单词如果存在字典中，那一定在左半边；否则就在右半边。
    - 根据第二步的判断，选择左半边或者后半边，继续迭代式地查找，直到范围缩小到单个的词。如果到最终仍然无法找到，则返回不存在。
- 机器学习算法中的迭代。相关算法或者模型有很多，比如 K- 均值算法（K-means clustering）、PageRank 的马尔科夫链（Markov chain）、梯度下降法（Gradient descent）等等。迭代法之所以在机器学习中有广泛的应用，是因为很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解。而迭代法可以帮助学习算法逐步搜索，直至发现这种解。

### 归纳

- 从理论上证明某个结论，节约大量的计算资源和时间
- 平时谈的“归纳” 一种从经验事实中找出普遍特征的认知方法

### 迭代法和递归  归纳

- 迭代法和递归都是通过不断反复的步骤，计算数值或进行操作的方法。
  - 迭代一般适合正向思维，而递归一般适合逆向思维。
  - 递归回溯的时候，也体现了正向递推的思维。本身都是抽象的流程，可以有不同的编程实现。
- 对于某些重复性的计算，数学归纳法可以从理论上证明某个结论是否成立。如果成立，它可以大大节约迭代法中数值计算部分的时间。不过，在使用数学归纳法之前，我们需要通过一些数学知识，假设命题，并证明该命题成立。
- 对于那些无法使用数学归纳法来证明的迭代问题，我们可以通过编程实现。这里需要注意的是，广义上来说，递归也是迭代法的一种。不过，在计算机编程中，我们所提到的迭代是一种具体的编程实现，是指使用循环来实现的正向递推，而递归是指使用函数的嵌套调用来实现的逆向递推。当然，两种实现通常是可以相互转换的。
- 循环的实现很容易理解，对硬件资源的开销比较小。不过，循环更适合“单线剧情”，例如计算 2^n，n!，1+2+3+…+n 等等。而对于存在很多“分支剧情”的复杂案例而言，使用递归调用更加合适。
- 利用函数的嵌套调用，递归编程可以存储很多中间变量。我们可以很轻松地跟踪不同的分支，而所有这些对程序员基本是透明的。如果这时使用循环，我们不得不自己创建并保存很多中间变量。当然，正是由于这个特性，递归比较消耗硬件资源。
- 递归编程本身就体现了分治的思想，这个思想还可以延伸到集群的分布式架构中。最近几年比较主流的 MapReduce 框架也体现了这种思想。
- 综合上面说几点，大致遵循这样原则
  - 如果一个问题可以被迭代法解决，而且是有关数值计算的，那就看看是否可以假设命题，并优先考虑使用数学归纳法来证明
  - 如果需要借助计算机，那么优先考虑是否可以使用循环来实现。如果问题本身过于复杂，再考虑函数的嵌套调用，是否可以通过递归将问题逐级简化
  - 如果数据量过大，可以考虑采用分治思想的分布式系统来处理

## 概率统计

## 线性代数

## 综合应用
