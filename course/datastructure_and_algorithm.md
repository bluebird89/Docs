## [数据结构与算法之美](https://time.geekbang.org/column/intro/126) 王争

- 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
- 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
- 学习的过程中碰到最大的问题，坚持不下来
	- 给自己设立一个切实可行的目标

![[../_static/ds_al.png]]

## [复杂度分析](../algorithm/algorithms.md#复杂度分析)

## 基础

- 线性表（Linear List）就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向
	- 数组，链表、队列、栈
- 非线性表 数据之间并不是简单的前后关系

### 数组 Array

- 一种线性表数据结构。用一组连续内存空间，来存储一组具有相同类型的数据
- 实现随机访问 连续内存空间和相同类型数据
	- 数组支持随机访问，根据下标随机访问时间复杂度为 O(1)
	- 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据
	- `a[i]_address = base_address + i * data_type_size`
	- `a[i][j] (i < m,j < n)` `address = base_address + ( i * n + j) * type_size`
	- “下标”最确切定义“偏移（offset）”
	- 从 0 开始编号实现了统一
- 连续内存空间和相同类型数据 让数组删除、插入操作变得非常低效，为保证连续性需要做大量数据搬移工作
	- JVM 标记清除垃圾回收算法 先记录下已经删除数据。每次删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正删除操作，大大减少删除操作导致的数据搬移
- 越界问题
	- 在 C 语言中，只要不是访问受限内存，所有内存空间都是可以自由访问
		- 函数体内局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为
		- 栈是向下增长的，首先压栈的i，`a[2]，a[1]，a[0]`
		- 例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了
	- 数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，程序就可能不会报任何错误
-  Java ArrayList 
	-  优势
		- 可以将很多数组操作细节封装起来
		- 支持动态扩容 
			- 数组本身在定义时需要预先指定大小，因为需要分配连续内存空间。如果申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，就需要重新分配一块更大空间，将原来数据复制过去，然后再将新数据插入
			- 使用 ArrayList，完全不需要关心底层的扩容逻辑，ArrayList 已经实现好了。每次存储空间不够的时候，都会将空间自动扩容为 1.5 倍大小
			- 扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小
	- 用数组会更合适些
		- Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组
		- 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组
		- 当要表示多维数组时，用数组往往会更加直观。比如` Object[][] array;`用容器定义：`ArrayList<ArrayList<object> > array`

```c
// a[3] 被定位到某块不属于数组的内存地址上，而@TODO这个地址正好是存储变量 i 内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

### 链表 Linked list

- 通过“指针”将一组零散内存块串联起来使用
	- 内存块称为链表“结点”
	- 为将所有结点串起来，每个链表结点除了存储数据之外，还需要记录链上下一个结点地址(后继指针 next)
- 单链表
	- 头结点 第一个结点 用来记录链表基地址。有了它，可以遍历得到整条链表
	- 尾结点 最后一个结点,特殊地方：指针不是指向下一个结点，而是指向一个空地址 NULL，表示链表上最后一个结点
	- 随机访问第 k 个元素需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点 O(n)
	- 插入和删除一个数据 O(1)
- 双向链表
	- 每个结点有一个后继指针 next 指向后面结点，还有一个前驱指针 prev 指向前面结点
	- 删除值等于给定值的结点对应链表 操作总时间复杂度为 O(n)
	- 删除给定指针指向结点
		- 单链表并不支持直接获取前驱结点，为了找到前驱结点，要从头结点开始遍历链表，直到 p->next=q，说明 p 是 q 的前驱结点
		- 双向链表 O(1) 的时间复杂度
	- 在链表某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度
	- 对于一个有序链表，双向链表按值查询效率也要比单链表高一些
		- 可以记录上次查找位置 p，每次查询时，根据要查找值与 p 大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据
	- 用空间换时间 当内存空间充足时,追求代码执行速度，可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构
- 循环链表
	- 尾结点指针是指向链表的头结点
	- 优点 从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题
- 双向循环链表
- 注意
	- 理解指针或引用含义
		- “指针”还是“引用” 存储所指对象内存地址
		- 将某个变量赋值给指针，实际上将变量地址赋值给指针，或者反过来说，指针中存储变量的内存地址，指向这个变量，通过指针就能找到这个变量
	- 警惕指针丢失和内存泄漏
		- 插入结点时，一定要注意操作顺序，要先将插入结点 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏
	- 利用哨兵简化实现难度
		- 向空链表中插入第一个结点,第一个结点和其他结点插入逻辑是不一样的
		- 删除链表最后一个结点
		- head 表示头结点指针，指向链表中的第一个结点,head 指针都会一直指向哨兵结点。有哨兵结点的链表叫带头链表
		- 哨兵结点不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，可以统一为相同代码实现逻辑
	- 重点留意边界条件处理
		- 如果链表为空时，代码是否能正常工作？
		- 如果链表只包含一个结点时，代码是否能正常工作？
		- 如果链表只包含两个结点时，代码是否能正常工作？
		- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
	- 举例画图，辅助思考
- 链表 VS 数组
	- 数组简单易用，在实现上使用连续内存空间，可以借助 CPU 的缓存机制，预读数组中数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读
	- 数组缺点 大小固定，一经声明就要占用整块连续内存空间。如果声明数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，与数组最大区别
- 判断一个字符串是否是回文字符串
	- @TODO 快慢两个指针找到链表中点 
		- 慢指针每次前进一步，快指针每次前进两步
		- 后半段链表reversed|慢指针前进过程中，同时修改其 next 指针，使得链表前半部分反序
		- 最后比较中点两侧的链表是否相等
		- 空间复杂度 O(n)
- 常见操作
	- 单链表反转
	- 链表中环的检测
	- 两个有序的链表合并
	- 删除链表倒数第 n 个结点
	- 求链表中间结点
	- 链表反转
- 写链表代码主要锻炼写代码能力，倒不是思考解决办法。像环检测这种解决办法想不出来 
	- 实现之前的思考时间不要太长。一是先用自己能想到的暴力方法实现试试
	- 另外在一定时间内(比如半个到一个小时)实在想不到就要在网上搜搜答案
	- 有的算法，比如链表中环的检测，最优解法还是挺巧妙的，一般来说不是生想就能想到的

![[../_static/linklist_insert_delete.png]]

### 最近最少使用策略 LRU Least Recently Used

- 有序单链表
	- 维护一个有序单链表，越靠近链表尾部结点是越早之前访问的(头插)
	- 当有一个新数据被访问时，从链表头开始顺序遍历链表
		- 已被缓存在链表中 遍历得到数据对应结点，并将其从原来位置删除，再插入到链表头部
		- 没有在缓存链表中
			- 缓存未满，则将此结点直接插入到链表头部
			- 缓存已满，则链表尾结点删除，将新数据结点插入链表头部
	- @TODO 反转
- 散列表（Hash table）来记录每个数据位置，将缓存访问时间复杂度降到 O(1)

