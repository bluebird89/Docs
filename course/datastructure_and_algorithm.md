## [数据结构与算法之美](https://time.geekbang.org/column/intro/126) 王争

- 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
- 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
- 学习过程中碰到最大的问题，坚持不下来
  - 给自己设立一个切实可行的目标

![[../_static/ds_al.png]]

## [复杂度分析](../algorithm/algorithms.md#复杂度分析)

## 数据结构

- 线性表（Linear List）就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向
  - 数组，链表、队列、栈
- 非线性表 数据之间并不是简单的前后关系
- 特定数据结构是对特定场景的抽象

### 数组 Array

- 一种线性表数据结构。用一组连续内存空间，来存储一组具有相同类型的数据
- 实现随机访问 连续内存空间和相同类型数据
  - 数组支持随机访问，根据下标随机访问时间复杂度为 O(1)
  - 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据
  - `a[i]_address = base_address + i * data_type_size`
  - `a[i][j] (i < m,j < n)` `address = base_address + ( i * n + j) * type_size`
  - “下标”最确切定义“偏移（offset）”
  - 从 0 开始编号实现了统一
- 连续内存空间和相同类型数据 让数组删除、插入操作变得非常低效，为保证连续性需要做大量数据搬移工作
  - JVM 标记清除垃圾回收算法 先记录下已经删除数据。每次删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正删除操作，大大减少删除操作导致的数据搬移
- 越界问题
  - 在 C 语言中，只要不是访问受限内存，所有内存空间都是可以自由访问
    - 函数体内局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为
    - 栈是向下增长的，首先压栈的i，`a[2]，a[1]，a[0]`
    - 例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了
  - 数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，程序就可能不会报任何错误
- Java ArrayList
  - 优势
    - 可以将很多数组操作细节封装起来
    - 支持动态扩容
      - 数组本身在定义时需要预先指定大小，因为需要分配连续内存空间。如果申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，就需要重新分配一块更大空间，将原来数据复制过去，然后再将新数据插入
      - 使用 ArrayList，完全不需要关心底层的扩容逻辑，ArrayList 已经实现好了。每次存储空间不够的时候，都会将空间自动扩容为 1.5 倍大小
      - 扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小
  - 用数组会更合适些
    - Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组
    - 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组
    - 当要表示多维数组时，用数组往往会更加直观。比如`  Object[][] array; `用容器定义：`ArrayList<ArrayList<object> > array`

```c
// a[3] 被定位到某块不属于数组的内存地址上，而@TODO这个地址正好是存储变量 i 内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

### 链表 Linked list

- 通过“指针”将一组零散内存块串联起来使用
  - 内存块称为链表“结点”
  - 为将所有结点串起来，每个链表结点除了存储数据之外，还需要记录链上下一个结点地址(后继指针 next)
- 单链表
  - 头结点 第一个结点 用来记录链表基地址。有了它，可以遍历得到整条链表
  - 尾结点 最后一个结点,特殊地方：指针不是指向下一个结点，而是指向一个空地址 NULL，表示链表上最后一个结点
  - 随机访问第 k 个元素需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点 O(n)
  - 插入和删除一个数据 O(1)
- 双向链表
  - 每个结点有一个后继指针 next 指向后面结点，还有一个前驱指针 prev 指向前面结点
  - 删除值等于给定值的结点对应链表 操作总时间复杂度为 O(n)
  - 删除给定指针指向结点
    - 单链表并不支持直接获取前驱结点，为了找到前驱结点，要从头结点开始遍历链表，直到 p->next=q，说明 p 是 q 的前驱结点
    - 双向链表 O(1) 的时间复杂度
  - 在链表某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度
  - 对于一个有序链表，双向链表按值查询效率也要比单链表高一些
    - 可以记录上次查找位置 p，每次查询时，根据要查找值与 p 大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据
  - 用空间换时间 当内存空间充足时,追求代码执行速度，可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构
- 循环链表
  - 尾结点指针是指向链表的头结点
  - 优点 从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题
- 双向循环链表
- 注意
  - 理解指针或引用含义
    - “指针”还是“引用” 存储所指对象内存地址
    - 将某个变量赋值给指针，实际上将变量地址赋值给指针，或者反过来说，指针中存储变量的内存地址，指向这个变量，通过指针就能找到这个变量
  - 警惕指针丢失和内存泄漏
    - 插入结点时，一定要注意操作顺序，要先将插入结点 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏
  - 利用哨兵简化实现难度
    - 向空链表中插入第一个结点,第一个结点和其他结点插入逻辑是不一样的
    - 删除链表最后一个结点
    - head 表示头结点指针，指向链表中的第一个结点,head 指针都会一直指向哨兵结点。有哨兵结点的链表叫带头链表
    - 哨兵结点不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，可以统一为相同代码实现逻辑
  - 重点留意边界条件处理
    - 如果链表为空时，代码是否能正常工作？
    - 如果链表只包含一个结点时，代码是否能正常工作？
    - 如果链表只包含两个结点时，代码是否能正常工作？
    - 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
  - 举例画图，辅助思考
- 链表 VS 数组
  - 数组简单易用，在实现上使用连续内存空间，可以借助 CPU 的缓存机制，预读数组中数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读
  - 数组缺点 大小固定，一经声明就要占用整块连续内存空间。如果声明数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，与数组最大区别
- 判断一个字符串是否是回文字符串
  - @TODO 快慢两个指针找到链表中点
    - 慢指针每次前进一步，快指针每次前进两步
    - 后半段链表reversed|慢指针前进过程中，同时修改其 next 指针，使得链表前半部分反序
    - 最后比较中点两侧的链表是否相等
    - 空间复杂度 O(n)
- 常见操作
  - 链表中环的检测
  - 两个有序链表合并
  - 删除链表倒数第 n 个结点
  - 求链表中间结点
  - 链表反转
- 写链表代码主要锻炼写代码能力，倒不是思考解决办法。像环检测这种解决办法想不出来
  - 实现之前的思考时间不要太长。一是先用自己能想到的暴力方法实现试试
  - 另外在一定时间内(比如半个到一个小时)实在想不到就要在网上搜搜答案
  - 有的算法，比如链表中环的检测，最优解法还是挺巧妙的，一般来说不是生想就能想到的

![[../_static/linklist_insert_delete.png]]

#### 最近最少使用策略 LRU Least Recently Used

- 有序单链表
  - 维护一个有序单链表，越靠近链表尾部结点是越早之前访问的(头插)
  - 当有一个新数据被访问时，从链表头开始顺序遍历链表
    - 已被缓存在链表中 遍历得到数据对应结点，并将其从原来位置删除，再插入到链表头部
    - 没有在缓存链表中
      - 缓存未满，则将此结点直接插入到链表头部
      - 缓存已满，则链表尾结点删除，将新数据结点插入链表头部
- 散列表（Hash table）来记录每个数据位置，将缓存访问时间复杂度降到 O(1)

### 栈 Stack

- 后进先出，先进后出
- 一种“操作受限”的线性表，只允许在一端插入和删除数据
- 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出特性
- 操作：入栈 push()和出栈 pop()，在栈顶插入一个数据和从栈顶删除一个数据
  - 空间复杂度是 O(1)  n 个空间是必须的，只需要一两个临时变量存储空间
  - 时间复杂度都是 O(1)
- 顺序栈 用数组实现的栈
- 链式栈 用链表实现的栈
- 支持动态扩容
  - 底层依赖一个支持动态扩容的数组就可以
  - 入栈操作 当栈中有空闲空间时，时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，时间复杂度变成 O(n)，均摊时间复杂度 O(1)
- 应用
  - 函数调用栈
    - 操作系统给每个线程分配一块独立内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时临时变量
    - 每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈
    - 函数调用符合后进先出特性，用栈这种数据结构来实现是最顺理成章的选择
    - 只要能保证每进入一个新函数，都是一个新作用域就可以。实现这个，用栈就非常方便
    - 内存空间在逻辑上分为三部分
      - 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换
      - 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收
      - 动态数据区
        - 栈区：存储运行方法形参、局部变量、返回值。由系统自动分配和回收
        - 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。
  - 表达式求值中 加减乘除四则运算
    - 通过两个栈实现。一个保存操作数的栈，另一个是保存运算符的栈
    - 从左向右遍历表达式，遇到数字直接压入操作数栈；遇到运算符，就与运算符栈的栈顶元素进行比较
    - 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈
    - 如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较
  - 括号匹配 给一个包含三种括号的表达式字符串，如何检查它是否合法
    - 用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，`“[”跟“]”`匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式
  - 浏览器的前进、后退功能
    - 用两个栈

```java
// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           //栈的大小

  // 初始化数组，申请一个大小为n的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }

  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回false，入栈失败。
    if (count == n) return false;
    // 将item放到下标为count的位置，并且count加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回null
    if (count == 0) return null;
    // 返回下标为count-1的数组元素，并且栈中元素个数count减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```

### 队列 queue

- 一种操作受限的线性表数据结构 先进者先出
- 操作
  - 入队 enqueue()，放一个数据到队列尾部
  - 出队 dequeue()，从队列头部取一个元素
- 线程池大小设置
  - CPU 资源是有限的，任务处理速度与线程个数并不是线性正相关
  - 过多线程反而会导致 CPU 频繁切换，处理性能下降
  - 一般都是综合考虑要处理任务的特点和硬件环境，来事先设置
- 要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾
- 顺序队列 用数组实现的队列
  - 随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据
  - 在入队时，集中触发一次数据搬移操作
- 链式队列 用链表实现的队列
- 循环队列
  - 避免数据搬移操作
  - 队空 head == tail
  - 队满 (tail+1)%n=head
- 阻塞队列
  - 队列为空，从队头取数据会被阻塞。没有数据可取，直到队列中有数据才能返回
  - 队列已满，插入数据操作会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回
  - 就是一个“生产者 - 消费者模型
- 并发队列
  - 线程安全的队列
  - 最简单直接实现方式直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作
  - 实际上，基于数组循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。也是循环队列比链式队列应用更加广泛原因
- 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢
  - 非阻塞处理方式，直接拒绝任务请求
  - 阻塞处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理
    - 先进者先服务 公平地处理每个排队的请求
    - 基于链表可以实现一个支持无限排队无界队列（unbounded queue），但会导致过多请求排队等待，请求处理响应时间过长
    - 基于数组实现的有界队列（bounded queue），队列大小有限，所以线程池中排队请求超过队列大小时，接下来的请求就会被拒绝
      - 对响应时间敏感的系统来说，就相对更加合理

```java
// 用数组实现的队列
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head表示队头下标，tail表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为capacity的数组
  public ArrayQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

   // 入队操作，将item放入队尾
  public boolean enqueue(String item) {
    // tail == n表示队列末尾没有空间了
    if (tail == n) {
      // tail ==n && head==0，表示整个队列都占满了
      if (head == 0) return false;
      // 数据搬移
      for (int i = head; i < tail; ++i) {
        items[i-head] = items[i];
      }
      // 搬移完之后重新更新head和tail
      tail -= head;
      head = 0;
    }
    
    items[tail] = item;
    ++tail;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果head == tail 表示队列为空
    if (head == tail) return null;
    // 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了
    String ret = items[head];
    ++head;
    return ret;
  }
}
```

## 思想

### 分治

- 分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了
- 分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧

### 动态规划

## 实现

### 递归 Recursion

- 看电影问你现在坐在第几排
  - 问前面一排的人他是第几排，只要在他的数字上加一，就知道自己在哪一排了
  - 前面的人也看不清啊，所以他也问他前面的人
  - 就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来
  - 直到你前面的人告诉你他在哪一排
- 上面是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”
- 所有递归问题都可以用递推公式来表示
- 满足的三个条件
  - 一个问题的解可以分解为子问题的解
  - 这个问题与分解之后的子问题，除数据规模不同，求解思路完全一样
  - 存在递归终止条件
- 写递归代码
  - **如何将大问题分解为小问题的规律**，并基于此写出递推公式
  - 再推敲终止条件
  - 将递推公式和终止条件翻译成代码
  - 编写递归代码关键 只要遇到递归，就把它抽象成一个递推公式，不用想一层层调用关系，不要试图用人脑去分解递归每个步骤
- 归纳法
  - 思维误区
    - 人脑几乎没办法把整个“递”和“归”过程一步一步都想清楚
    - 把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去
  - 正确思维方式
    - 如果一个问题 A 可以分解为若干子问题 B、C、D，可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A
    - 只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节
- 利 递归代码的表达力很强，写起来非常简洁
- 弊 空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题
  - 堆栈溢出 在代码中限制递归调用最大深度，超过一定深度（比如 1000）之后就不继续往下再递归了，直接返回报错
  - 重复计算 通过一个数据结构（比如散列表）来保存已经求解过的 f(k)
- 将递归代码改写为非递归代码
  - 根据实际情况来选择是否需要用递归的方式来实现
  - 笼统讲递归本身借助系统或者虚拟机本身提供的栈来实现的，没有感知罢了。如果自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子
  - 这种思路实际上将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度
- 调试
  - 打印日志发现，递归值
  - 结合条件断点进行调试

```java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}


int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```

### 排序

- 分析
  - 执行效率
    - 最好情况、最坏情况、平均情况时间复杂度,最好、最坏时间复杂度对应的要排序的原始数据是什么样
    - 时间复杂度的系数、常数 、低阶 在对同一阶时间复杂度的排序算法性能对比时要把系数、常数、低阶也考虑进来
  - 内存消耗
    - 原地排序（Sorted in place）特指空间复杂度是 O(1) 排序算法
  - 稳定性 如果待排序序列中存在值相等元素，经排序后相等元素之间原有先后顺序不变
    - 排序的是一组对象，需要按照对象的某个 key 来排序
    - 给电商交易系统中10 万条订单数据排序。订单有两个属性，一个是下单时间，另一个是订单金额。按照金额从小到大对订单数据排序。对于金额相同订单按照下单时间从早到晚有序
      - 先按照金额对订单数据进行排序，然后再遍历排序后的订单数据，对于每个金额相同小区间再按照下单时间排序
      - 先按照下单时间给订单排序，排序完成之后，用稳定排序算法，按照订单金额重新排序
        - 稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变
- 有序度 数组中具有有序关系的元素对个数
  - 有序元素对 `a[i] <= a[j]` 如果i < j
  - 满有序度 完全有序数组 有序度 `n*(n-1)/2`
- 逆序度的定义正好跟有序度相反（默认从小到大为有序）
  - 逆序元素对 `a[i] > a[j]`, 如果i < j
  - 逆序度 = 满有序度 - 有序度
- 排序过程 一种增加有序度，减少逆序度过程，最后达到满有序度
- 

| 方法 | 是否原地 | 是否稳定 | 最好     | 最坏     | 平均       |
| -- | ---- | ---- | ------ | ------ | -------- |
| 冒泡 | yes  | yes  | O(n)   | O(n^2) | O(n^2)   |
| 插入 | yes  | yes  | O(n)   | O(n^2) | O(n^2)   |
| 选择 | yes  | no   | O(n^2) | O(n^2) | O(n^2)   |
| 归并 |      |      |        |        | O(nlogn) |
| 快速 |      |      |        |        | O(nlogn) |
| 计数 |      |      |        |        | O(n)     |
| 基数 |      |      |        |        | O(n)     |
| 桶  |      |      |        |        | O(n)     |

#### 冒泡排序 Bubble Sort

- 未排序区最大值**冒出来**放到排序区
  - 冒泡 只会操作相邻两个数据。每次冒泡操作都会对相邻两个元素进行比较，不满足就互换
  - 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，完成 n 个数据的排序
- 优化 当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操
- 原地排序算法 空间复杂度 O(1)
- 稳定排序算法 相邻元素大小相等时不做交换 相同大小数据在排序前后不会改变顺序
- 最好情况时间复杂度 O(n) 要排序的数据已经有序，只需要进行一次冒泡操作，就可以结束
- 最坏情况时间复杂度 O(n^2) 要排序数据刚好是倒序排列的，需要进行 n 次冒泡操作
- 平均时间复杂度  O(n2)
  - 冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即逆序度 = `n*(n-1)/2`–初始有序度
  - 平均情况下，需要 `n*(n-1)/4` 次交换操作

```java
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

#### 插入排序 Insertion Sort

- 将未排序区数据**插入到**已排序区
  - 将数组中数据分为两个区间，已排序区间和未排序区间
  - 初始已排序区间只有一个元素，数组第一个元素
  - 取未排序区间中元素，在已排序区间中找到合适插入位置将其插入，保证已排序区间数据一直有序
  - 重复这个过程，直到未排序区间中元素为空，算法结束
- 将数据 a 插入到已排序区间时，需要拿 a 与已排序区间元素依次比较大小，找到合适插入位置。找到插入点后，需要将插入点之后元素顺序往后移动一位，这样才能腾出位置给元素 a 插入
  - 不同的查找插入插入点方法（从头到尾、从尾到头),移动次数总是固定的，就等于逆序度
- 原地排序算法 空间复杂度是 O(1)
- 稳定排序算法
- 最好时间复杂度为 O(n) 要排序数据已经有序,每次只需要比较一个数据就能确定插入的位置.从尾到头遍历已经有序数据
- 最坏情况时间复杂度 O(n2) 数组是倒序的，每次插入都相当于在数组第一个位置插入新的数据
- 为什么插入排序要比冒泡排序更受欢迎
  - 冒泡排序的数据交换比插入排序的数据移动复杂，冒泡排序需要 3 个赋值操作，而插入排序需要 1 个

```java

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

#### 选择排序 Selection Sort

- 每次从未排序区间中找到最小元素(选择)放到已排序区间末尾
- 空间复杂度为 O(1) 一种原地排序算法
- 最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)
- 不稳定的排序算法

#### 归并排序 Merge Sort

- 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序两部分合并在一起，整个数组就都有序
- 拆分到单个元素，merge 逻辑是通用的
- 递推公式 `merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))`
- 终止条件 `p >= r` 不用再继续分解
- 借助哨兵
- 稳定排序算法
- 时间复杂度
	- 对 n 个元素进行归并排序需要时间 T(n)，分解成两个子数组排序时间都是 T(n/2)
	- merge() 函数合并两个有序子数组的时间复杂度是 O(n)
	- `T(n) = 2*T(n/2) + n=2^k * T(n/2^k) + k * n`
	- 当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，得到 k=log2n
	- T(n) = O(nlogn)
	- 与要排序的原始数组的有序程度无关，时间复杂度非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)
- 不是原地排序
	- 在合并两个有序数组为一个有序数组时，需要借助额外存储空间
	- 尽管每次合并操作都需要申请额外内存空间，但在合并完成之后，临时开辟内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据大小，所以空间复杂度是 O(n)

![[../_static/merge_sort.png]]

```java
// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}

merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}


T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
```

#### 快速排序 Quicksort

- 实现
	- 排序下标从 p 到 r 之间一组数据，选择 p 到 r 之间任意一个数据作为 pivot（分区点）
	- 遍历 p 到 r 之间数据，小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间
	- 数组 p 到 r 之间数据被分成三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间 pivot，后面的 q+1 到 r 之间是大于 pivot 的
	- 可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1
	- 递推公式 `quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)`
	- 终止条件 `p >= r`
	- partition() 分区函数 选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间最后一个元素），然后对 `A[p...r]`分区，函数返回 pivot 下标

```java
// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}

// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}

partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i
```