## 代码整洁之道 clean code

#book #code

- 代码大部分时候是用来维护的，而不是用来实现功能
  - 编译好让机器执行，完成功能需求
  - 写给身边的队友和自己看的，需要长期维护
- 设计模式只是手段，代码清晰才是目的
  - 防止过度设计，大部分抽象只有一个实现的时候，要好好思考一下，是不是设计有点过度了，清晰永远是第一准则

## 指导原则

- 程序员终其一生所做得事大抵不超过这几个层次
  - 函数与类
  - 包与模块(依赖)
  - 服务(系统)与服务域
  - 产品
- 消除重复
  - 代码重复同一段代码出现两次及以上，就应该抽取出函数
  - 结构重复
    - 继承体系
    - 泛型
    - 模板方法 template method
    - 高阶函数，lambda
  - 过程重复自动化
- 分离关注点
  - 分离主线和支线 主要业务逻辑是主线，应该突出主线,，淡化支线
    - AOP
    - interceptor、filter 等
  - 分离技术和业务 技术型代码常常是公用的，如日期计算、日志记录、性能测量、数据库链接、基础工具类。这些应该和业务逻辑分开
  - 按业务性质分离
    - 不同业务应该分开，在模块级、服务级甚至更高的产品级，这也应该是共识。但是在一个系统内部，推荐也应该按业务分成不同的包
  - 分离变化快慢的代码
  - 分离性能高低的代码 重 I/O 代码和重 CPU 代码理应分开，方便合理分配资源，其他诸如此类的代码应该注意分开
- 统一抽象层次
  - 将有关认识与那些在实际中和他们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。——John Locke 《关于人类理解的随笔》
  - 抽象表达的是意图，不表达细节
  - 同一抽象层次上的对象才能直接对话
  - 同一抽象层次上的对象之间存在着紧密合作
  - 一个好的函数结构，应该像一棵树一样层次分明
    - 一方面，每一个层次都只有 2~5 个步骤
    - 一个好的函数，不应该超过 5 行
  - 好的程序读起来应该像自然语言，极少部分像数学语言(偏算法)
  - 信息隐藏，是抽象的一种手段
    - 通过信息隐藏，来暴露只想让外界知道的东西，表达意图
    - 隔离是实现信息隐藏的重要手段

### 目标

- 可操作性
- 健壮性
- 可测试性
- 可维护性
- 易用性
- 可重用性

## Practice

- 静态检查
  - 多读开源代码和身边优秀同学的代码
  - 开源社区，为我们提供了这么好的学习机会。无论是JDK的源码，还是经典的Netty、Spring、Jetty，还是一些小工具如Guava等
- code review
  - 凡是能通过机器检查出来的事情，无需通过人
  - 更应该关注代码的设计与风格:一段功能是不是应该属于一个类、是不是有很多相似的功能可以抽取出来复用、代码太过冗长难懂等等
  - 集体code review，因为很多时候，组里相对高级的工程师能够一眼发现代码存在较大设计缺陷，提出改进意见或者重构方式。我们可以在整个小组内形成一个好的文化传承和风格统一，并且很大程度上培养了大家对clean code的热情
- 勤于重构
  - 掌握一些常见的“无痛”重构技巧，这在下文会有具体讲解。
  - 小步快跑，不要企图一口吃成个胖子。改一点，测试一点，一方面减少代码merge的痛苦，另一方面减少上线的风险。
  - 建立自动化测试机制，要做到即使代码改坏了，也能保证系统最小核心功能的可用，并且保证自己修改的部分被测试覆盖到。
  - 熟练掌握IDE的自动重构功能。很大程度上减少体力劳动，避免犯错
- 对模块应用良好的原则
  - 尽可能减少依赖
  - 每个项目应该有一个明确的职责
  - 不要重复自身

## Skills

- 单一职责
  - 定义东西，如果不能用一句话描述清楚职责，就把它拆掉
  - 把方法拆细是复用的基础
- 优先定义整体框架
  - 写很多空实现，来把整体业务流程穿起来
  - 良好方法签名，用入参和出参来控制流程。避免陷入业务细节无法自拔
  - 脑海中先定义清楚流程几个阶段，并为每个阶段找到合适的方法／类归属.无论读到什么深度，都可以清晰地了解每一层职能，如果不care下一层的实现，完全可以跳过不看，并且方法的粒度也会恰到好处
  - 写代码时“广度优先”而不是“深度优先
- 清晰命名
  - 思考一个方法命名的时间比写一段代码的时间还长。原因还是那个逻辑：每当写出一个类似于"temp"、"a"、"b"这样变量的时候，后面每一个维护代码的人，都需要用几倍的精力才能理顺
  - 代码自描述最重要的基础
- 避免过长参数
  - 参数长度超过4个，就需要警惕了
    - 没有人能够记得清楚这些函数的语义
    - 代码的可读性会很差
  - 如果参数非常多，意味着一定有很多参数，在很多场景下，是没有用的
  - 解决:构造paramObject。用一个struct或者一个class来承载数据，一般这种对象是value object，不可变对象。这样，能极大程度提高代码的可复用性和可读性。在必要的时候，提供合适的build方法，来简化上层代码的开发成本
- 避免过长方法和类
  - 横向拆分:根据业务，把建立／更新／修改／通知等逻辑拆到不同的类里去
  - 纵向拆分:把数据库操作/MQ操作/Cache操作/对象校验等，拆到不同的对象里去，让主流程尽量简单可控，让同一个类，表达尽量同一个维度的东西
- 让相同长度的代码段表示相同粒度的逻辑:尽量多地去抽取private方法，让代码具有自描述的能力
- 面向对象设计技巧
  - 贫血与领域驱动
  - 为每个方法找到合适的类归属，数据和行为尽量要在一起:主张数据和行为在一起
    - service对象。如果操作一个对象数据的所有方法都建立在对象内部，可能使对象承载了很多并不属于它本身职能的方法
    - 如果一个行为，无法明确属于哪个领域对象，牵强地融入领域对象里，会显得很不自然。这时候，无状态的service可以发挥出它的作用。但一定要把握好这个度，回归本质，要把属于每个模型的行为合理的去划定归属
  - 警惕 static
    - 真正适用场景：工具方法，而不是业务方法
  - 巧用method object
    - 一个有数据有行为的对象。依赖的数据会成为这个对象的变量，所有的行为会成为这个对象的内部方法
    - 利用成员变量代替参数传递，会让代码简洁清爽很多。并且，把一段过程式的代码转换成对象代码，为很多面向对象编程才可以使用的继承／封装／多态等提供了基础
- 面向接口编程
  - 正确使用继承和组合
    - protected abstract 最值得使用继承，父类保留扩展点，子类扩展
    - protected final 子类是只能使用不能修改实现
      - 抽象出主流程不能被修改的，然而一般情况下，public final更适合这个职能。如果只是流程的一部分，需要思考这个流程的类归属，大部分变成public组合到其他类里是更合适的
      - 父类是抽象类无法直接对外提供服务，又不希望子类修改它的行为，这种大多数情况下属于工具方法，比较适合用另一个领域对象来承载并用组合的方式来使用
    - protected 这种是有争议的，是父类有默认实现但子类可以扩展的。凡是有扩展可能的，使用继承更理想一些。否则，定义成final并考虑成组合
    - 继承更多的是为扩展提供便利，为复用而存在的方法最好使用组合的方式
- 代码复用技巧
  - 模板方法
    - 每当有两个行为类似但又不完全相同的代码段时
    - 提取公共流程和可复用的方法到父类，保留不同的地方作为abstract方法，由不同的子类去实现
    - 在合适的时机refactor，pull method up（复用）或者 pull method down（特殊逻辑）
    - 把不属于流程的、但可复用的方法，判断是不是属于基类的领域职责，再使用继承或者组合的方法，为这些方法找到合适的安家之处
  - extract method
  - 责任链
    - 一连串类似的行为，只是数据或者行为不一样。如一堆校验器，如果成功怎么样、失败怎么样；或者一堆对象构建器，各去构造一部分数据。碰到这种场景，我总是喜欢定义一个通用接口，入参是完整的要校验／构造的参数
    - 出参是成功/失败的标示或者是void。然后有很多实现器分别实现这个接口，再用一个集合把这堆行为串起来。最后，遍历这个集合，串行或者并行的执行每一部分的逻辑
    - 好处
      - 很多通用的代码可以在责任链原子对象的基类里实现；
      - 代码清晰，开闭原则，每当有新的行为产生的时候，只需要定义行的实现类并添加到集合里即可；
      - 为并行提供了基础
  - 为集合显式定义操作封装起来
  - 对于有明确语义的集合的一些操作，尤其是全局的集合或者被经常使用的集合，做一些封装和抽象，如把Map封装成一个Cache类或者一个config类，再提供GetFromCache这样的方法

### 分层分包

- 本质就是隔离

-分层原则 只能上层调用下层，而不能反过来，反之容易导致循环依赖。

- 分包原则 同一个包中的对象天然是亲和的，同时对包外的对象是不亲和(隔离)的
- DDD 微服务经典四层分层是一个更好的实践，重视业务、重视 OO
- dao 的表达能力同样很弱，dao 里的方法很难表达意图，语义表达能力很弱

### 类

- 应该足够小
- 职责应该单一意味着，“只有一个理由可以修改它”
- 类名一般而言应该是名词，且描述其职责
- 如果无法为一个类名以精确的名称，这个类大概就太长了。类名越含混，该类越有可能拥有过多的权责。——《Clean Code》
- 内聚 类的每一个字段都应该被某个(些)方法所使用到。如果不能达到这个结果，应该考虑是否类的字段应该拆分出去成为新的类。
- 严格控制访问权限，注意信息隐藏，OCP
  - 访问权限应该能小则小。能 private 就不要 package，能 package 就不要 protected。
  - 更好的遵循 OCP 原则。最稳定的系统，是从不修改的系统
- 业务复杂情况应该使用 repository，repository 通过组合规格(specification)来表达查询语义，repository 是仓储的概念，类似一个 ADT，只有有限几个经过仔细设计的方法，类比一个 map 就理解了。关于更多为何不使用 dao 而应该使用 repository 的知识，可参考 <https://thinkinginobjects.com/2012/08/26/dont-use-dao-use-repository/>

### 函数

- 尽可能小
  - 控制在 10 行以内，至多 20 行，除非是细节代码
  - 函数越小，功能越集中，越便于取一个好名字
  - 做不到原因可能：函数功能太多，职责不单一；函数抽象层次划分不清；语言支持不够等
- 应该做一件事,做好这件事
  - 如何确定函数做的那件事是什么
  - 一个可靠判断准则：函数内容(函数体内的代码)只是做了函数所在抽象层级的步骤，那这个函数就是只做了一件事
  - 函数所在抽象层级，根据对业务的理解，应该用良好的函数名加以示意
- 一个函数应该只在一个抽象层次上。自顶向下读代码
  - 每个函数都应该保留一个抽象层级，而且尽量只做一件事
  - 抽象 要做的事情的概念，而不是具体的细节实现
- 参数尽量少
  - 参数带了极大的语义干扰，而且也难于测试
  - 不要超过 3 个参数，除非有非常特殊的理由
  - 典型不好设计
    - 用 bool 作为公开函数的参数，因为 bool 变量天然地会使人想到这个函数不会只做一件事，它分情况处理，bool 入参的命名稍有歧义就会使人困惑
      - 将 bool 参数的函数私有，另外公开两个语义清晰的函数
- 无副作用
  - 函数作用 要么函数无修改的 get 一个结果，要么就是单纯修改而不返回修改以外的结果
- if 嵌套不应超过 2 层
  - 提前返回，将嵌套 if 铺陈开来，使不满足条件的分支提前返回
  - 碰到第三个 if，直接将其抽取为函数(简单粗暴)
  - lambda，在 Java 里利用 stream 的扁平化处理，使 filter、map 等语法元素都可以接收简单的函数，从而避免在 for 里加 if 判断。对于集合的遍历处理，都应该尽量先采用 stream 的做法，这种流水线的思想，在一个步骤里就剔除了不满足条件的对象，然后流转到下一个步骤
- 语义和实现距离不为 0 时应该抽取函数
  - 在高抽象层次时，函数应该表达意图，而只有在叶子结点——抽象层次最低的实现部分才表达实现，这个地方的代码更像是程序。
  - 在代码中的某个位置，本应该表达意图，却写了细节实现代码，这就应该抽取出函数
  - 代码应该表达意图，特别是 if 条件分支里，不要让人再去推理，直接表达语义
- 童子军军规
  - 走的时候，比来的时候干净一点。代码中如果能经常注意这一点，每时每刻都在改善代码。
  - 世界是朝着熵增的方向发展的，譬如一个房间，即使完全不去干扰它，久而久之它也会变得更加混乱，代码也是这样，终究会变得越来越混乱、难以修改、难以维护
  - 如果不注意这一点，反而每次来都扔一点垃圾，久而久之就会成为“破窗”直至“破楼”
- 任何时候都不应该在代码中直接出现 hardcode，hardcode 难以表达语义，且难以管理。

### 命名与注释

- 所知的一切，都是命名，存在、宗教、知识、伦理...没有命名，所知的一切所谓知识都将崩塌
- There are only two hard things in Computer Science: cache invalidation and naming things. ——Phil Karlson
- 顾名思义、望文知义、无歧义
  - 清楚明白无歧义地表达含义，不要让别人猜你的意思。在 API 设计里，有一条原则即是“Don't Let Me Think”，命名也应该如此，乃至日常工作沟通中也应当如此
- 名副其实
- 表达语义，避免误导
  - 命名不应该表达实现(如 List 实现，数据结构等)，而应该表达语义。
- 使用读得出来的名字，谨慎使用缩写
- 团队统一业务术语
- 注释不能让写的烂的代码变的更好。如果别人只能依靠注释读懂代码时一定要反思代码出现了什么问题
- 注释场景
	- public interface，向别人明确发布功能的语义，输入输出，且不需要关注实现
	- 功能容易有歧义的点，或者涉及比较深层专业知识的时候。比如，如果你写一个客户端，各种config 参数含义等
    
### 单元测试

- 保证软件质量和代码质量
- 对于修改代码或重构的重要性无可替代
  - 对于拥有一组完善单测的函数，可以随意更改，只要让修改后的函数通过单测，就几乎是安全修改的
  - 单元测试铺了一张安全网，像走钢丝一样地写代码不至于失足跌入深渊万劫不复。
- tips：
  - 不能依赖真实依赖，这是大忌。如依赖真实数据库且数据库出错，并不能检验单测所测函数逻辑失败，而是外部造成的，应该 mock，且对一般对象也应该尽量使用 mock 对象；否则即为集成测试；
  - 路径应该尽可能全；
  - 不能有条件分支，任何条件分支都应该新开单测；
  - 单测也应该像业务代码一样，干净整洁；
  - realBug 测试是必要的，发生过一次的事情很有可能会反复发生，我们选择题第一次选错了，第二次还是很可能选择上次的那个错误答案

### 心智负担与复杂

- Complexity is caused by two things: dependencies and obscurity.
- 消除心智负担一定程度上意味着增加可读性和可维护性。
